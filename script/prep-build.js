#!/usr/bin/env node
const path = require('path')
const fs = require('fs')
const glob = require('glob')
const chalk = require('chalk')

const PROJECT_DIR = path.join(__dirname, '..')
const FACETS_SRC_DIR = path.join(PROJECT_DIR, 'src', 'facets')
const INTERFACES_SRC_DIR = path.join(PROJECT_DIR, 'src', 'interfaces')
const GENERATED_DEPLOY_NAMES_SOL = path.join(PROJECT_DIR, 'script', 'generated', 'LibGeneratedFacetHelpers.sol')

// load facets
const facetNames = glob.sync('*Facet.sol', { cwd: FACETS_SRC_DIR }).map(a => path.basename(a).substring(0, a.indexOf('Facet')))

// load interfaces and methods
const facetData = {}
const REGEX = /^\s+function ([A-Za-z0-9_]+)\(/igm
facetNames.forEach(f => {
  try {
    const interfaceName = `I${f}Facet`
    const src = fs.readFileSync(path.join(INTERFACES_SRC_DIR, `${interfaceName}.sol`)).toString('utf-8')
    const methods = []
    let m
    while ((m = REGEX.exec(src))) {
      methods.push(m[1])
    }
    if (!methods.length) {
      
      throw new Error(`Empty interface`)
    }
    facetData[f] = {
      interfaceName,
      methods,
    }
  } catch (err) {
    console.error(chalk.red(`Error loading interface for facet ${f}`))
    throw err
  }
})

console.log(chalk.blue('== Facets =='))
Object.entries(facetData).forEach(([facetName, data]) => {
  console.log(`${facetName} - ${data.methods.length} methods`)
})

// write metadata solidity file
fs.writeFileSync(GENERATED_DEPLOY_NAMES_SOL, `
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 <0.9;

/// ------------------------------------------------------------------------------------------------------------
///
/// NOTE: this file is auto-generated by ${path.basename(__filename)}, please DO NOT modify it directly.
///
/// ------------------------------------------------------------------------------------------------------------

import { IDiamondCut } from "lib/diamond-2-hardhat/contracts/interfaces/IDiamondCut.sol";

${facetNames.map((n, i) => `
import { ${n}Facet } from "src/facets/${n}Facet.sol";
import { I${n}Facet } from "src/interfaces/I${n}Facet.sol";
`).join("\n")}

enum FacetAddressIndex {
  ${facetNames.join(",\n  ")}
}

library LibGeneratedFacetHelpers {
  function getFacetNames() internal pure returns (string[] memory facetNames) {
    facetNames = new string[](${facetNames.length});
    ${facetNames.map((n, i) => `facetNames[uint256(FacetAddressIndex.${n})] = "${n}";`).join("\n    ")}
  }

  function createDiamondFunctionsCut(address[] memory facetAddresses) internal pure returns (IDiamondCut.FacetCut[] memory cut) {
    // initialize the diamond as well as cut in all facets
    cut = new IDiamondCut.FacetCut[](${facetNames.length});

    // yul too slow, so fix stack too deep here
    {
      ${facetNames.map((n, i) => {
        const { interfaceName, methods } = facetData[n];
        
        const selectors = methods.map((m, mi) => `f${i}[${mi}] = ${interfaceName}.${m}.selector;`)

        const str1 = `bytes4[] memory f${i} = new bytes4[](${methods.length});
      ${selectors.join("\n      ")}`

        const str2 = `cut[${i}] = IDiamondCut.FacetCut({
          facetAddress: address(facetAddresses[uint256(FacetAddressIndex.${n})]),
          action: IDiamondCut.FacetCutAction.Add,
          functionSelectors: f${i}
      });`
        
        return `${str1}\n      ${str2}`
      }).join("\n      ")}
    }
  }

  function deployFacets() internal returns (address[] memory facetAddresses) {
    facetAddresses = new address[](${facetNames.length});
    ${facetNames.map(n => `facetAddresses[uint256(FacetAddressIndex.${n})] = address(new ${n}Facet());`).join("\n    ")}
  }


  function deployAndCutFacets(address proxy) internal {
    address[] memory facetAddresses = deployFacets();
    IDiamondCut.FacetCut[] memory cut = createDiamondFunctionsCut(facetAddresses);
    IDiamondCut(proxy).diamondCut(cut, address(0), "");
  }
}
`, { encoding: 'utf-8'})
